# ログイン突破 Part 3
3. 自動ログイン突破の既存手法
自動ログインを実現するため、開発者たちは様々な工夫を凝らしています。Devinに適用できそうな既存の突破手法を整理すると、以下のようになります。

3.1 ブラウザ自動操作ツール（Selenium / Playwright）の活用
SeleniumやPlaywrightは、プログラムから実際のブラウザを制御できる強力なツールです。これらを用いて人間の操作をエミュレートすることで、通常のログインフローをそのまま自動化できます。Devinも内部でコードを実行できるため、これらのツールを用いたログインスクリプトを作成させることが考えられます。

しかし通常の使い方では前述の通りBot検知に引っかかるため、いくつかの対策が必要です。

ステルスモード（ブラウザ指紋の偽装）: Selenium使用時、標準のChromeDriverではnavigator.webdriverがtrueになるなど自動化の指紋が残ります。selenium-stealthというPythonパッケージを使うと、ブラウザの各種識別情報を人間の操作と同じように偽装できます​
STACKOVERFLOW.COM
。例えば以下のコードでは、ヘッドレスChromeに対しWebDriverフラグの削除、User-Agent偽装、言語やレンダラ情報の設定を行っています​
STACKOVERFLOW.COM
。
python
コピーする
from selenium import webdriver
from selenium_stealth import stealth

options = webdriver.ChromeOptions()
options.add_argument("--headless")
options.add_experimental_option("excludeSwitches", ["enable-automation"])
options.add_experimental_option('useAutomationExtension', False)
driver = webdriver.Chrome(options=options, executable_path="chromedriver.exe")

stealth(driver,
    languages=["en-US", "en"],
    vendor="Google Inc.",
    platform="Win32",
    webgl_vendor="Intel Inc.",
    renderer="Intel Iris OpenGL Engine",
    fix_hairline=True,
)
上記のように設定することで、サイト側の検知をある程度回避できます​
STACKOVERFLOW.COM
。実際、この手法を用いることで**「Seleniumによるログイン試行をサイトが検知してブロックする問題」が解決した**との報告があります​
STACKOVERFLOW.COM
​
STACKOVERFLOW.COM
。

Undetected-Chromedriverの利用: Seleniumをさらに隠密に使うため、コミュニティが提供するundetected-chromedriverという特殊なChromeDriverも有効です。【undetected-chromedriver】はChromeの起動時に自動化の痕跡をパッチで消し去り、Distil NetworksやCloudflare等のBot対策に引っかからないよう改良されたドライバです​
STACKOVERFLOW.COM
。例えば以下のコードで使用できます。
python
コピーする
import undetected_chromedriver as uc
from selenium import webdriver

options = webdriver.ChromeOptions() 
options.headless = True
options.add_argument("start-maximized")
# 可能なら自動化フラグを消すオプションも併用
options.add_experimental_option("excludeSwitches", ["enable-automation"])
options.add_experimental_option('useAutomationExtension', False)

driver = uc.Chrome(options=options)
driver.get('https://example.com/login')
undetected-chromedriverは内部でChromeDriverを適切に初期化し、ヘッドレス特有のHeadlessChromeというUA文字列を除去してくれます​
STACKOVERFLOW.COM
。これによりCloudflare等にブロックされにくくなります​
STACKOVERFLOW.COM
。実際、このドライバを使うことでCloudflareのブロックを回避できたとの事例があります​
STACKOVERFLOW.COM
​
STACKOVERFLOW.COM
。

ヘッドレスモードを避ける: 最終手段として、ヘッドレスブラウザを使わないことも検討されます。実際に画面を持ったブラウザを起動すれば、User-Agentに余計な”Headless”文字が付与されず、視覚的な検証（例えばCanvas要素への描画テストなど）も人間と同じように通過できる可能性があります​
STACKOVERFLOW.COM
。サーバー上でDevinを動かす場合、Xvfb（仮想ディスプレイ）を使って見えないフルブラウザを動かす手もあります​
STACKOVERFLOW.COM
。ヘッドレスを避けた結果Cloudflareのチェックを突破できた例もあります​
STACKOVERFLOW.COM
。

Playwrightの活用: PlaywrightもSelenium同様にブラウザ自動操作が可能で、かつ公式に複数ブラウザのサポートやコンテキストの保存機能があります。Playwrightでも基本対策は同じで、ブラウザの指紋を人間らしく偽装する必要があります。Puppeteer（Node.js用類似ツール）のコミュニティ製「stealthプラグイン」はPlaywrightにも応用可能です​
SCRAPEOPS.IO
。実際、とあるPlaywrightのガイドではGoogleログインを自動化するためにヘッドレスモードの検知回避を実装し、最終的にGoogleアカウントへの自動ログインに成功しています​
SCRAPEOPS.IO
​
SCRAPEOPS.IO
（Googleログイン突破のデモコードが掲載されています）。Playwrightはstorage state機能でログイン後のクッキーを保存し、次回テストに引き継ぐことも容易なため​
PLAYWRIGHT.DEV
、一度ログインに成功すればセッション維持にも役立ちます。

3.2 クッキー管理によるセッション引き継ぎ
一度人間がログインできる環境を用意できるなら、ログイン後のクッキーを保存して再利用する方法が非常に有効です。手順としては以下の通りです。

Selenium/Playwrightなどで手動またはスクリプトによりログイン（必要なら上記ステルス対策併用）。
ログイン後に取得できる認証クッキー（セッションIDなど）をファイルに保存する。
次回以降のアクセス時、そのクッキーをブラウザに読み込ませた状態から開始し、ログインページをスキップする。
具体的にはPython + Seleniumの場合、pickleを使ってクッキーのリストをシリアライズして保存できます​
STACKOVERFLOW.COM
。保存と読み込みの例を示します。

python
コピーする
import pickle
# (ログイン完了後のdriverを想定)
# クッキーを保存
pickle.dump(driver.get_cookies(), open("cookies.pkl", "wb"))
driver.quit()

# ...後日または別セッションで...
driver = webdriver.Chrome()  # 新しいブラウザ起動
driver.get("https://対象サイト")  # 一度サイトを開いてからでないとクッキーは追加できない
cookies = pickle.load(open("cookies.pkl", "rb"))
for cookie in cookies:
    driver.add_cookie(cookie)
driver.refresh()  # クッキーを反映して再読み込み
上記のように、取得したクッキーをcookies.pklに保存し、再利用時にdriver.add_cookie()でセットすることで、ログイン状態を復元できます​
STACKOVERFLOW.COM
​
STACKOVERFLOW.COM
。この方法なら、Devin自身が毎回難しいログイン処理をしなくても、事前に用意したクッキー情報を渡すだけで認証済みセッションを引き継げるわけです。

注意点として、クッキーには有効期限があるため、永続的に使えるわけではありません。またIPアドレスやUser-Agentが変わるとセッション無効になるサービスもあります。しかし同一環境であれば、数日〜数週間程度のセッション継続は可能な場合が多いです。例えばOpenAIのChatGPTはログインセッションが比較的長く維持されるため、一度クッキー取得に成功すればDevinにそのクッキーを保持させておくだけで長期間自動利用できる可能性があります。

3.3 APIキー・トークンの活用（裏口からの認証）
最も堅実かつ推奨される突破法は、公式に用意されたAPI認証手段を使うことです。つまり、ウェブのGUIからログインする代わりに、サービス提供のAPIを直接叩いて必要な操作を行うアプローチです。Devinはコードを書いて実行できるため、もしサービスのAPIクレデンシャル（キーやトークン）を取得しておけば、ログイン操作そのものを省略できます。

ChatGPT(OpenAI): OpenAIは公式APIを提供しており、APIキーを使えばChatGPT同等の機能（GPT-4/GPT-3.5モデルへのクエリ）を実行可能です。したがって、ChatGPTのウェブにログインして操作させるよりも、DevinにはOpenAI APIキーを与え、API経由で問い合わせを行わせた方が簡単で確実です。実際、多くの開発者はブラウザを自動化する代わりにOpenAI APIを活用しています。ただしブラウザでしかできない機能（プラグインの使用、Browsing機能など）が必要な場合は、この限りではありません。

AWS: AWSは極めて充実したAPIとSDKを持つサービスです。アクセスキーIDとシークレットキーを発行し、さらに必要ならMFA用のシードを共有することで、DevinがAWSリソースにプログラム経由でアクセスできるようになります​
DEV.CLASSMETHOD.JP
​
DEV.CLASSMETHOD.JP
。実際の事例では、Devinのシークレット管理機能にAWSのアクセスキー類と仮想MFAデバイスのARN・シード値を登録し、STS（一時トークン発行）経由で認証させることに成功しています​
DEV.CLASSMETHOD.JP
​
DEV.CLASSMETHOD.JP
。この方法ではAWSコンソールのGUIにログインさせる必要はなく、Devinに対して「AWSコマンドを使ってリソースを操作せよ」と指示すれば、裏でaws sts get-session-tokenやAWS SDK (boto3等)を用いてタスクを実行できます​
DEV.CLASSMETHOD.JP
​
DEV.CLASSMETHOD.JP
。つまりAWSの突破はAPI認証の利用でほぼ解決でき、難易度は低いと言えます。

GCP: GCPもまた豊富なAPI群があります。Devinに対し、サービスアカウントのJSONキーを提供すれば、gcloud CLIやGoogle Cloud Client Librariesを用いてあらゆる操作が可能です。Firebase CLIの例でも、対話式ログインはできなくても**「Firebaseダッシュボードから生成したJSONキー」で認証できた**と報告されています​
NOTE.COM
。GCPの場合、サービスアカウントに適切な権限を与え、その鍵で認証させることが突破策となります。これにより、Webコンソールへのログインという手順を回避できます。

Mapify: Mapifyに関して公的なAPIは確認できませんでした。ただ、MapifyはGoogleやAppleアカウントでログインできるようなので、もし公式にAPIがなければブラウザ自動操作か**代替ログイン（メールアドレス＆パスワード）**を検討します。Mapifyが独自アカウントをサポートするなら、ユーザー登録してメールログインし、そのクッキーを保存しておく戦略が考えられます。Googleログインしかない場合は、前述のGoogle認証突破手法（ステルスブラウザ）が必要になります。

Zapier: Zapier自体の操作を自動化するための公式APIは限定的ですが、Zapierは外部サービスとの連携を担うプラットフォームです。もしDevinにZapier上でのワークフロー構築やトリガー実行をさせたいなら、Zapier提供のPartner API（開発者向けAPI）やZapier CLIを使う方法があります。ZapierのPartner APIではZaps（自動化ルール）の作成・管理がREST経由で可能ですが、利用にはZapierの開発者プログラム参加が必要です​
COMMUNITY.ZAPIER.COM
。代替として、ブラウザ自動操作でZapierの画面を操作することもできます。Zapierのログインはメールアドレス＆パスワードまたはGoogleログインです。前者であればSeleniumでフォーム送信すれば比較的容易にログインできます（Zapier側に特段のボット検知は報告されていません）。つまりZapier単体のログイン突破は難易度中程度ですが、そもそもZapier経由でやりたい事の多く（他サービスの連携）はDevinから直接各サービスAPIを叩くことで代替可能な場合もあります​
NOTE.COM
​
DEV.CLASSMETHOD.JP
。

3.4 その他の手法・工夫
上記以外にも、現場ではさまざまな工夫が凝らされています。

人間との協調: 完全自動に固執せず、ログイン部分だけ人間が支援してあげるアプローチです。例えば初回ログイン時にDevinが一時停止し、人間に「認証コードを入力してください」や「CAPTCHAを解いてください」と促すような実装も可能でしょう。これにより、一度セッションを取得してしまえばあとはDevinが自動処理を続行できます。ただしDevin自身がそうした対話プロンプトを出す機能があるかは要確認です（Slack連携のUIなどで実現する余地はあります）。

環境構築の共有: 例えばDevin用に**ログイン済みのブラウザ環境（プロファイル）**をあらかじめ用意し、その環境ごとDevinに渡すという方法も考えられます。Chromeの場合、--user-data-dirオプションで特定のユーザープロファイルを指定できます​
STACKOVERFLOW.COM
。ログイン済みのクッキーやローカルストレージ情報がそのプロファイルに含まれていれば、Devinが起動したブラウザでも継続利用できます。ただ、Devinの実行環境がクラウド上で常に新規インスタンスならこの方法は使いづらいです。

ログインページ以外からの侵入: 稀なケースですが、サイトによってはログインなしでも取得できるトークンやクッキーから権限を昇格できてしまう脆弱性があることも知られています​
ITPRO.COM
。そうした手法は正攻法ではないため本調査の範囲外ですが、セキュリティ研究の観点では議論されています。ただしDevinに不正アクセスを試させることは規約違反や法的問題となるため、正規のAPIや公式機能を使うのが無難でしょう。

以上の手段を組み合わせることで、多くのサービスで自動ログインが可能になると考えられます。次章では、ログイン後にDevinがどのようにセッションを維持しタスクを続行できるか、その技術的可能性について述べます。
