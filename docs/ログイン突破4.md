# ログイン突破 Part 4

4. ログイン後のタスク継続とセッション維持
自動ログインが成功したとして、重要なのはその後Devinが連続して操作を行えるかです。セッション維持の仕組みと、Devin固有の課題について解説します。

4.1 セッションの維持方法
ウェブサービスでは一度ログインすると、以後のリクエストにはセッションIDクッキーやBearerトークンを付与することで認証状態を保持します。従ってDevinがログイン後に継続して操作するには、そのセッション情報を使い回し続ければよいことになります。具体的な維持方法は先述のクッキー管理と同様です。

同一ブラウザインスタンスの再利用: Selenium/Playwrightでログイン処理を行ったブラウザ（WebDriverオブジェクト）を、そのまま次の操作にも使い回せばセッションは保たれます。例えば、ログイン後にdriver.get("ユーザ専用ページURL")を呼べば、ログインセッションが有効な限りそのページ内容を取得できます。このようにログインから各種操作までを一つのブラウザセッション内で連続的に行うのが理想です。Devinにタスクを与える際も、「ログイン→情報取得→処理→ログアウト」と一連の行程を一度の指示で実行させれば、セッションが途切れる心配はありません。

セッション情報の保存: 長時間のタスクや複数セッションに跨る場合、セッション情報を明示的に保存・読み込みする必要があります。Devinの場合、セッション内で得た認証情報は新しいセッションには引き継がれないとされています​
NOTE.COM
。例えばSlack上のDevinとの対話で一つのスレッドがひとつのセッションですが、新たなスレッドでは環境がリセットされます​
NOTE.COM
。このため、AWSの事例では**「今後の開発で利用するために何らかの引き継ぎが必要」**と指摘され、環境スナップショットを取るかセットアップスクリプトを用意することが提案されています​
NOTE.COM
。具体的には、認証後の状態（例えば~/.aws/credentialsファイルやトークン）を保存し、新セッション開始時にそれを読み込む処理を自動化する、といった方法です。

Devinのシークレット/Knowledge機能: DeveloperがDevinに認証情報やノウハウを覚えさせるための機能が提供されています。先のAWSエンジニア化記事では、DevinのSecretsストアにクレデンシャルを登録し、Knowledgeベース（知識のメモ）に「AWSアクセス時はSecrets内の資格情報を使うこと」「直接キーを使わずSTSで一時キーを取得すること」といったルールを記載しています​
DEV.CLASSMETHOD.JP
​
DEV.CLASSMETHOD.JP
。この結果、Devinはセッションが変わってもそのKnowledgeに従い、毎回正しい方法でログインプロセス（厳密にはログインではなくAPI認証）を実行できます​
DEV.CLASSMETHOD.JP
​
DEV.CLASSMETHOD.JP
。つまり一種のログインスクリプトをDevin自身に記憶させているわけです。

リフレッシュトークンの活用: OAuth2系のサービスではアクセストークンと共にリフレッシュトークンを取得できる場合があります。リフレッシュトークンがあれば、ログインなしに新しいアクセストークン（有効期限延長）を発行できます。Devinが一度OAuthフローを完了したなら、その後は取得したリフレッシュトークンを保存しておき、定期的にアクセストークンを更新することで永続的に認証を維持できます。これは例えばGoogle APIsやZapierがOAuth接続する先のサービス（Twitter等）でも使われる仕組みです​
DOCS.ZAPIER.COM
​
DOCS.ZAPIER.COM
。

要するに、ログイン後のセッションさえDevinが保持できれば、以降は通常の利用と同じように連続操作が可能です。課題はDevinのセッションが切り替わる際にその状態をどう渡すかですが、SecretsやKnowledgeへの記録、スナップショット機能の活用などが鍵になります。

4.2 Devin固有の課題と可能性
DevinはSlackをインターフェースに動作する自律エージェントであり、以下の固有の点があります。

セッションの寿命: Devinは1セッション（Slackの1スレッド）内であればステートフルに動作できますが、スレッドを跨ぐとコンテキストがリセットされます​
NOTE.COM
。したがって長期的なセッション維持には、同じスレッドで走り続けるか、状態を明示的に保存する必要があります。前者は人間が対話を続ければよいですが、自律的に定期タスクを走らせる場合、スナップショット→スケジューリングといったサポートが必要です。Devin自体にcron的な機能があるか不明ですが、外部からSlackメッセージを定期送信するなどで擬似的に実現可能でしょう。

秘密情報の取り扱い: セッション維持にはしばしばトークンやクッキーといった秘密情報を取り扱います。Devinはチャット経由での直接秘密情報受け渡しを禁止しています​
NOTE.COM
。そのため、必ずSecrets機能などを用いて安全に渡す必要があります​
DEV.CLASSMETHOD.JP
​
DEV.CLASSMETHOD.JP
。幸いDevinにはSecretsストアが用意されており、これを使えばクッキー文字列やトークンも保存できます。ただしAWSのTOTPシードのように特殊扱いのフィールドでは不具合も報告されているため（2025/02時点でTOTPをうまく利用できないケースがある​
DEV.CLASSMETHOD.JP
）、場合によっては平文で保存するなどワークアラウンドが必要です​
DEV.CLASSMETHOD.JP
。

タスク継続実行の制御: Devinは指示に従ってコードを書き、実行し、結果を報告するサイクルを回します。ログイン後に連続的に操作するコードを書くこと自体は可能ですが、長時間マルチステップな処理になると、人間のレビューなしに走らせて大丈夫かという問題もあります。Devinにはタスク実行前に承認を求める設定もあるようなので​
ZENN.DEV
、自動ログイン後の重要操作は適宜人間が確認しつつ進めるのが安全でしょう。

以上を踏まえれば、Devinがログイン後にタスクを継続実行することは技術的に可能です。適切にセッション情報を受け渡し、Devinに継続手順を学習・保存させれば、ログイン後の操作も自律的にこなせるでしょう。実際に次章で紹介する成功事例では、ログイン後のシナリオをDevinが処理できている様子が伺えます。
